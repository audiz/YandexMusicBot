////////////////////////////////////////////////////////////////////////////////
// The following FIT Protocol software provided may be used with FIT protocol
// devices only and remains the copyrighted property of Garmin Canada Inc.
// The software is being provided on an "as-is" basis and as an accommodation,
// and therefore all warranties, representations, or guarantees of any kind
// (whether express, implied or statutory) including, without limitation,
// warranties of merchantability, non-infringement, or fitness for a particular
// purpose, are specifically disclaimed.
//
// Copyright 2021 Garmin Canada Inc.
////////////////////////////////////////////////////////////////////////////////
// ****WARNING****  This file is auto-generated!  Do NOT edit this file.
// Profile Version = 21.53Release
// Tag = production/akw/21.53.00-0-g1b82aa2b
////////////////////////////////////////////////////////////////////////////////


package com.garmin.fit;

import java.io.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CodingErrorAction;
import java.nio.charset.StandardCharsets;

import java.lang.NumberFormatException;

public abstract class FieldBase {
    protected ArrayList<Object> values;
    static boolean forceShowInvalids;

    static {
        forceShowInvalids = !Fit.ENABLE_LEGACY_BEHAVIOUR;
    }

    protected FieldBase() {
        this.values = new ArrayList<Object>();
    }

    public FieldBase(final FieldBase other) {
        this.values = new ArrayList<Object>();
        if(other != null) {
            for (Object value : other.values) {
                this.values.add(value);
            }
        }
    }

    public String getName() {
        return getNameInternal(null);
    }

    private String getNameInternal(SubField subField) {
        if (subField == null) {
            return getFieldName();
        } else {
            return subField.name;
        }
    }

    public String getName(int subFieldIndex) {
        return getNameInternal(getSubField(subFieldIndex));
    }

    public String getName(String subFieldName) {
        return getNameInternal(getSubField(subFieldName));
    }

    public abstract String getUnits();
    public abstract int getType();
    protected abstract double getOffset();
    protected abstract double getScale();
    protected abstract String getFieldName();
    protected abstract SubField getSubField(String subFieldName);
    protected abstract SubField getSubField(int subFieldIndex);

    public int getType(int subFieldIndex) {
        return getTypeInternal(getSubField(subFieldIndex));
    }

    public int getType(String subFieldName) {
        return getTypeInternal(getSubField(subFieldName));
    }

    private int getTypeInternal(SubField subField) {
        if (subField == null) {
            return getType();
        } else {
            return subField.type;
        }
    }

    public String getUnits(int subFieldIndex) {
        return getUnitsInternal(getSubField(subFieldIndex));
    }

    public String getUnits(String subFieldName) {
        return getUnitsInternal(getSubField(subFieldName));
    }

    private String getUnitsInternal(SubField subField) {
        if (subField == null) {
            return getUnits();
        } else {
            return subField.units;
        }
    }

    int getSize() {
        int size = 0;

        switch (getType()) {
        case Fit.BASE_TYPE_ENUM:
        case Fit.BASE_TYPE_UINT8:
        case Fit.BASE_TYPE_UINT8Z:
        case Fit.BASE_TYPE_SINT8:
        case Fit.BASE_TYPE_BYTE:
        case Fit.BASE_TYPE_SINT16:
        case Fit.BASE_TYPE_UINT16:
        case Fit.BASE_TYPE_UINT16Z:
        case Fit.BASE_TYPE_SINT32:
        case Fit.BASE_TYPE_UINT32:
        case Fit.BASE_TYPE_UINT32Z:
        case Fit.BASE_TYPE_FLOAT32:
        case Fit.BASE_TYPE_FLOAT64:
        case Fit.BASE_TYPE_SINT64:
        case Fit.BASE_TYPE_UINT64:
        case Fit.BASE_TYPE_UINT64Z:
            size = getNumValues() * Fit.baseTypeSizes[getType() & Fit.BASE_TYPE_NUM_MASK];
            break;

        case Fit.BASE_TYPE_STRING:
            for (Object value : values) {
                try {
                    size += value.toString().getBytes("UTF-8").length + 1;
                } catch (UnsupportedEncodingException ignored) {
                }
            }
            break;

        default:
            break;
        }

        return size;
    }

    // rawValue is already the correct quantity (scale/offsets applied) but possibly not the
    // correct underlying type
    public void addRawValue(Object rawValue) {

        if (rawValue == null) {
            values.add(null);
        }
        // Add a scaled/offset value as the underlying field type rather than double
        else if (rawValue instanceof Double) {
            switch (getType()) {
            case Fit.BASE_TYPE_ENUM:
            case Fit.BASE_TYPE_UINT8:
            case Fit.BASE_TYPE_UINT8Z:
            case Fit.BASE_TYPE_SINT16:
            case Fit.BASE_TYPE_BYTE:
                values.add((short)(Math.round(((Number)rawValue).doubleValue())));
                break;

            case Fit.BASE_TYPE_SINT8:
                values.add((byte)(Math.round(((Number)rawValue).doubleValue())));
                break;

            case Fit.BASE_TYPE_UINT16:
            case Fit.BASE_TYPE_UINT16Z:
            case Fit.BASE_TYPE_SINT32:
                values.add((int)(Math.round(((Number)rawValue).doubleValue())));
                break;

            case Fit.BASE_TYPE_UINT32:
            case Fit.BASE_TYPE_UINT32Z:
                values.add(Math.round(((Number)rawValue).doubleValue()));
                break;

            case Fit.BASE_TYPE_FLOAT32:
                values.add(rawValue);
                break;
            case Fit.BASE_TYPE_FLOAT64:
                values.add(rawValue);
                break;
            case Fit.BASE_TYPE_STRING:
                values.add((rawValue).toString());
                break;
            default:
                break;
            }
        }
        else if ((rawValue instanceof String) && (rawValue.equals(""))) {
            switch (getType()) {
            case Fit.BASE_TYPE_ENUM:
                values.add(Fit.ENUM_INVALID);
                break;
            case Fit.BASE_TYPE_SINT8:
                values.add(Fit.SINT8_INVALID);
                break;
            case Fit.BASE_TYPE_UINT8:
                values.add(Fit.UINT8_INVALID);
                break;
            case Fit.BASE_TYPE_UINT8Z:
                values.add(Fit.UINT8Z_INVALID);
                break;
            case Fit.BASE_TYPE_SINT16:
                values.add(Fit.SINT16_INVALID);
                break;
            case Fit.BASE_TYPE_UINT16:
                values.add(Fit.UINT16_INVALID);
                break;
            case Fit.BASE_TYPE_UINT16Z:
                values.add(Fit.UINT16Z_INVALID);
                break;
            case Fit.BASE_TYPE_SINT32:
                values.add(Fit.SINT32_INVALID);
                break;
            case Fit.BASE_TYPE_UINT32:
                values.add(Fit.UINT32_INVALID);
                break;
            case Fit.BASE_TYPE_UINT32Z:
                values.add(Fit.UINT32Z_INVALID);
                break;
            case Fit.BASE_TYPE_STRING:
                values.add(rawValue);
                break;
            case Fit.BASE_TYPE_FLOAT32:
                values.add(Fit.FLOAT32_INVALID);
                break;
            case Fit.BASE_TYPE_FLOAT64:
                values.add(Fit.FLOAT64_INVALID);
                break;
            case Fit.BASE_TYPE_BYTE:
                values.add(Fit.BYTE_INVALID);
                break;
            default:
                break;
            }
        } else {
            values.add(rawValue);
        }
    }

    public int getNumValues() {
        return values.size();
    }

    protected boolean isSignedInteger() {
        return isSignedIntegerInternal(null);
    }

    protected boolean isSignedInteger(int subFieldIndex) {
        return isSignedIntegerInternal(getSubField(subFieldIndex));
    }

    protected boolean isSignedInteger(String subFieldName) {
        return isSignedIntegerInternal(getSubField(subFieldName));
    }

    public boolean isSignedIntegerInternal(SubField subField) {
        int type = subField == null ? getType() : subField.getType();
        switch (type) {
        case Fit.BASE_TYPE_SINT8:
        case Fit.BASE_TYPE_SINT16:
        case Fit.BASE_TYPE_SINT32:
        case Fit.BASE_TYPE_SINT64:
            return true;

        default:
            break;
        }

        return false;
    }

    /**
     * Determines if a field is valid
     * @return true if the currently active SubField is valid
     */
    public boolean isValid() {
        return isValid(0);
    }

    /**
     * Determines if an array member of a field is valid
     * @param index the index in the field array to check
     * @return true if the field member is valid
     */
    public boolean isValid(int index) {
        int type = getType(Fit.SUBFIELD_INDEX_ACTIVE_SUBFIELD);

        if (index >= values.size()) {
            return false;
        }

        Object value = values.get(index);

        if (value instanceof Number) {
            if(Fit.baseTypeInvalidMap.get(type).equals(value)) {
                return false;
            }
        }

        return true;
    }

    public Long getBitsValue(int offset, int bits, boolean signed) {
        long value = 0;
        int bitsInValue = 0;
        int bitsInData;
        int index = 0;
        Long data;
        Object objData;
        long mask;

        while (bitsInValue < bits) {
            // Remove the scale and offset (which previously had been been fixed at 1/0)
            // Work in raw to avoid rounds.  Caller shall apply scale/offset
            objData = getRawValueInternal(index++, null);

            if (objData == null) {
                return null;
            }
            if (!(objData instanceof Number)) {
                return null;
            }
            data = ((Number)objData).longValue();

            data >>= offset;
            bitsInData = Fit.baseTypeSizes[getType() & Fit.BASE_TYPE_NUM_MASK] * 8 - offset;
            offset -= Fit.baseTypeSizes[getType() & Fit.BASE_TYPE_NUM_MASK] * 8;

            if (bitsInData > 0) {
                offset = 0;

                if (bitsInData > (bits - bitsInValue)) {
                    bitsInData = bits - bitsInValue;
                }

                mask = ((long) 1 << bitsInData) - 1;
                value |= (data.longValue() & mask) << bitsInValue;
                bitsInValue += bitsInData;
            }
        }

        if (signed) {
            long signBit = (1L << (bits - 1));

            if ((value & signBit) != 0) {
                value = -signBit + (value & (signBit - 1));
            }
        }

        return value;
    }


    public Object getRawValue() {
        return getRawValueInternal(0, null);
    }

    public Object getRawValue(int fieldArrayIndex) {
        return getRawValueInternal(fieldArrayIndex, null);
    }

    public Object getRawValue(int fieldArrayIndex, int subFieldIndex) {
        return getRawValueInternal(fieldArrayIndex, getSubField(subFieldIndex));
    }

    public Object getRawValue(int fieldArrayIndex, String subFieldName) {
        return getRawValueInternal(fieldArrayIndex, getSubField(subFieldName));
    }

    protected Object getRawValueInternal(int fieldArrayIndex, SubField subField) {
        Object value;

        if (fieldArrayIndex >= values.size()) {
            return null;
        }

        value = values.get(fieldArrayIndex);
        return value;
    }

    public Object getValue() {
        return getValueInternal(0, null);
    }

    public Object getValue(int fieldArrayIndex) {
        return getValueInternal(fieldArrayIndex, null);
    }

    public Object getValue(int fieldArrayIndex, int subFieldIndex) {
        return getValueInternal(fieldArrayIndex, getSubField(subFieldIndex));
    }

    public Object getValue(int fieldArrayIndex, String subFieldName) {
        return getValueInternal(fieldArrayIndex, getSubField(subFieldName));
    }


    protected Object getValueInternal(int fieldArrayIndex, SubField subField) {
        Object value;
        double scale;
        double offset;

        if (fieldArrayIndex >= values.size()) {
            return null;
        }

        if (subField == null) {
            scale = getScale();
            offset = getOffset();
        } else {
            scale = subField.scale;
            offset = subField.offset;
        }

        int type = getTypeInternal(subField);
        value = values.get(fieldArrayIndex);

        if (value instanceof Number) {
            if(Fit.baseTypeInvalidMap.get(type).equals(value)) {
                return Fit.baseTypeInvalidMap.get(type);
            }

            if ((scale != Fit.FIELD_DEFAULT_SCALE) || (offset != Fit.FIELD_DEFAULT_OFFSET)) {
                return ((Number) value).doubleValue() / scale - offset;
            }
        }

        return value;
    }

    public void setValue(Object value) {
        setValueInternal(0, value, null);
    }

    public void setValue(int fieldArrayIndex, Object value) {
        setValueInternal(fieldArrayIndex, value, null);
    }

    public void setValue(Object value, int subFieldIndex) {
        setValueInternal(0, value, getSubField(subFieldIndex));
    }

    public void setValue(Object value, String subFieldName) {
        setValueInternal(0, value, getSubField(subFieldName));
    }

    public void setValue(int fieldArrayIndex, Object value, int subFieldIndex) {
        SubField subField = null;

        if (subFieldIndex != Fit.SUBFIELD_INDEX_MAIN_FIELD) {
            subField = getSubField(subFieldIndex);

            if (subField == null) {
                throw new FitRuntimeException("com.garmin.fit.Field.setValue(): " + subFieldIndex + " is not a valid subfield index of " + getName() + ".");
            }
        }

        setValueInternal(fieldArrayIndex, value, subField);
    }

    public void setValue(int fieldArrayIndex, Object value, String subFieldName) {
        setValueInternal(fieldArrayIndex, value, getSubField(subFieldName));
    }

    private Object rangeCorrect(Integer type, Object value) {
        if (Fit.baseTypeMinMap.get(type) == null || Fit.baseTypeMaxMap.get(type) == null) {
            // Type does not have a range limit. Return value as is.
            return value;
        }

        try {
            BigDecimal min = new BigDecimal(Fit.baseTypeMinMap.get(type).toString());
            BigDecimal max = new BigDecimal(Fit.baseTypeMaxMap.get(type).toString());
            BigDecimal val = new BigDecimal(value.toString());
            if (val.compareTo(min) < 0 || val.compareTo(max) > 0) {
                return Fit.baseTypeInvalidMap.get(type);
            }
            else {
                return value;
            }
        }
        catch (NumberFormatException e) {
            return Fit.baseTypeInvalidMap.get(type);
        }

    }

    protected void setValueInternal(int fieldArrayIndex, Object value, SubField subField) {
        while (fieldArrayIndex >= getNumValues())
            addValue(new Object());

        double scale;
        double offset;

        if (subField == null) {
            scale = getScale();
            offset = getOffset();
        } else {
            scale = subField.scale;
            offset = subField.offset;
        }

        if (value == null) {
            values.set(fieldArrayIndex, null);
        } else if ((value instanceof Number) && ((scale != Fit.FIELD_DEFAULT_SCALE) || (offset != Fit.FIELD_DEFAULT_OFFSET))) {
            double rawValue = (((Number) value).doubleValue() + offset) * scale;
            switch (getType()) {
            case Fit.BASE_TYPE_ENUM:
            case Fit.BASE_TYPE_UINT8:
            case Fit.BASE_TYPE_UINT8Z:
            case Fit.BASE_TYPE_SINT16:
                values.set(fieldArrayIndex, rangeCorrect(getType(), Math.round(rawValue)));
                break;
            case Fit.BASE_TYPE_SINT8:
                values.set(fieldArrayIndex, rangeCorrect(getType(), Math.round(rawValue)));
                break;
            case Fit.BASE_TYPE_UINT16:
            case Fit.BASE_TYPE_UINT16Z:
            case Fit.BASE_TYPE_SINT32:
                values.set(fieldArrayIndex, rangeCorrect(getType(), Math.round(rawValue)));
                break;
            case Fit.BASE_TYPE_UINT32:
            case Fit.BASE_TYPE_UINT32Z:
            case Fit.BASE_TYPE_SINT64:
                values.set(fieldArrayIndex, rangeCorrect(getType(), Math.round(rawValue)));
                break;
            case Fit.BASE_TYPE_FLOAT32:
                values.set(fieldArrayIndex, rangeCorrect(getType(), rawValue));
                break;
            case Fit.BASE_TYPE_FLOAT64:
                values.set(fieldArrayIndex, rangeCorrect(getType(), rawValue));
                break;
            case Fit.BASE_TYPE_STRING:
                values.set(fieldArrayIndex, ((Double) rawValue).toString());
                break;

            case Fit.BASE_TYPE_UINT64:
            case Fit.BASE_TYPE_UINT64Z:
                Long val = Math.round(rawValue);
                int size = Fit.baseTypeSizes[getType() & Fit.BASE_TYPE_NUM_MASK];
                byte[] bytes = new byte[size];
                for(int i = 0; i < size; i++) {
                    bytes[i] = (byte)(val >>> (8 * i));
                }

                values.set(fieldArrayIndex, rangeCorrect(getType(), new BigInteger(1, bytes)));
                break;
            case Fit.BASE_TYPE_BYTE:
                // Byte base types are only invalid if all bytes in an array are set to invalid.
                values.set(fieldArrayIndex, Math.round(rawValue));
                break;
            default:
                break;
            }
        }
        else {
            SetValueUnscaled(fieldArrayIndex, value);
        }
    }

    private void SetValueUnscaled(int fieldArrayIndex, Object value) {
        if ((value instanceof String) && (value.equals(""))) {
            switch (getType()) {
            case Fit.BASE_TYPE_ENUM:
            case Fit.BASE_TYPE_SINT8:
            case Fit.BASE_TYPE_UINT8:
            case Fit.BASE_TYPE_UINT8Z:
            case Fit.BASE_TYPE_SINT16:
            case Fit.BASE_TYPE_UINT16:
            case Fit.BASE_TYPE_UINT16Z:
            case Fit.BASE_TYPE_SINT32:
            case Fit.BASE_TYPE_UINT32:
            case Fit.BASE_TYPE_UINT32Z:
            case Fit.BASE_TYPE_FLOAT32:
            case Fit.BASE_TYPE_FLOAT64:
            case Fit.BASE_TYPE_BYTE:
            case Fit.BASE_TYPE_SINT64:
            case Fit.BASE_TYPE_UINT64:
            case Fit.BASE_TYPE_UINT64Z:
                values.set(fieldArrayIndex, Fit.baseTypeInvalidMap.get(getType()));
                break;
            case Fit.BASE_TYPE_STRING:
                values.set(fieldArrayIndex, rangeCorrect(getType(), value));
                break;
            default:
                break;
            }
        } else if (value instanceof String) {
            int byteCount = ((String) value).getBytes(StandardCharsets.UTF_8).length;
            if(byteCount > Fit.STRING_MAX_BYTE_COUNT) {
                throw new FitRuntimeException(String.format("Invalid string size. Byte count can not be greater than %d bytes.",Fit.STRING_MAX_BYTE_COUNT));
            }
            values.set(fieldArrayIndex, value);
        } else {
            values.set(fieldArrayIndex, rangeCorrect(getType(), value));
        }
    }

    public void setRawValue(int fieldArrayIndex, Object rawValue) {
        while (fieldArrayIndex >= getNumValues()) {
            addValue(new Object());
        }

        if (rawValue == null) {
            values.set(fieldArrayIndex, null);
        }
        // Add a scaled/offset value as the underlying field type rather than double
        else if (rawValue instanceof Double) {
            switch (getType()) {
            case Fit.BASE_TYPE_ENUM:
            case Fit.BASE_TYPE_UINT8:
            case Fit.BASE_TYPE_UINT8Z:
            case Fit.BASE_TYPE_SINT16:
            case Fit.BASE_TYPE_BYTE:
                values.set(fieldArrayIndex, (short)(Math.round(((Number)rawValue).doubleValue())));
                break;

            case Fit.BASE_TYPE_SINT8:
                values.set(fieldArrayIndex, (byte)(Math.round(((Number)rawValue).doubleValue())));
                break;

            case Fit.BASE_TYPE_UINT16:
            case Fit.BASE_TYPE_UINT16Z:
            case Fit.BASE_TYPE_SINT32:
                values.set(fieldArrayIndex, (int)(Math.round(((Number)rawValue).doubleValue())));
                break;

            case Fit.BASE_TYPE_UINT32:
            case Fit.BASE_TYPE_UINT32Z:
            case Fit.BASE_TYPE_SINT64:
                values.set(fieldArrayIndex, Math.round(((Number)rawValue).doubleValue()));
                break;

            case Fit.BASE_TYPE_FLOAT32:
                values.set(fieldArrayIndex, rawValue);
                break;
            case Fit.BASE_TYPE_FLOAT64:
                values.set(fieldArrayIndex, rawValue);
                break;
            case Fit.BASE_TYPE_STRING:
                values.set(fieldArrayIndex, (rawValue).toString());
                break;

            case Fit.BASE_TYPE_UINT64:
            case Fit.BASE_TYPE_UINT64Z:
                Long val = Math.round(((Number) rawValue).doubleValue());
                int size = Fit.baseTypeSizes[getType() & Fit.BASE_TYPE_NUM_MASK];
                byte[] bytes = new byte[size];
                for(int i = 0; i < size; i++) {
                    bytes[i] = (byte)(val >>> (8 * i));
                }
                break;

            default:
                break;
            }
        } else {
            SetValueUnscaled(fieldArrayIndex, rawValue);
        }
    }

    public void addValue(Object value) {
        if ((value instanceof Number) && (getType() == Fit.BASE_TYPE_STRING)) {
            String string = getStringValueInternal(0, null);
            Number number = (Number) value;

            if (string == null) {
                string = "";
            }

            string += String.valueOf((char) (number.intValue()));
            setValueInternal(0, string, null);
            return;
        }

        values.add(value);
    }

    public Byte[] getByteValues() {
        return getByteValues((SubField)null);
    }

    public Byte[] getByteValues(int subfieldIndex){
        return getByteValues(getSubField(subfieldIndex));
    }

    public Byte[] getByteValues(String subfieldName){
        return getByteValues(getSubField(subfieldName));
    }

    protected Byte[] getByteValues(SubField subfield){
        Byte[] rv = new Byte[getNumValues()];

        for(int i = 0; i < getNumValues(); i++){
            rv[i] = getByteValueInternal(i, subfield);
        }

        return rv;
    }

    public Byte getByteValue() {
        return getByteValueInternal(0, null);
    }

    public Byte getByteValue(int fieldArrayIndex) {
        return getByteValueInternal(fieldArrayIndex, null);
    }

    public Byte getByteValue(int fieldArrayIndex, int subFieldIndex) {
        return getByteValueInternal(fieldArrayIndex, getSubField(subFieldIndex));
    }

    public Byte getByteValue(int fieldArrayIndex, String subFieldName) {
        return getByteValueInternal(fieldArrayIndex, getSubField(subFieldName));
    }

    protected Byte getByteValueInternal(int fieldArrayIndex, SubField subField) {
        Object value = getValueInternal(fieldArrayIndex, subField);

        if (value == null) {
            return null;
        }

        return ((Number) value).byteValue();
    }

    public Short[] getShortValues() {
        return getShortValues((SubField)null);
    }

    public Short[] getShortValues(int subfieldIndex){
        return getShortValues(getSubField(subfieldIndex));
    }

    public Short[] getShortValues(String subfieldName){
        return getShortValues(getSubField(subfieldName));
    }

    protected Short[] getShortValues(SubField subfield){
        Short[] rv = new Short[getNumValues()];

        for(int i = 0; i < getNumValues(); i++){
            rv[i] = getShortValueInternal(i, subfield);
        }

        return rv;
    }

    public Short getShortValue() {
        return getShortValueInternal(0, null);
    }

    public Short getShortValue(int fieldArrayIndex) {
        return getShortValueInternal(fieldArrayIndex, null);
    }

    public Short getShortValue(int fieldArrayIndex, int subFieldIndex) {
        return getShortValueInternal(fieldArrayIndex, getSubField(subFieldIndex));
    }

    public Short getShortValue(int fieldArrayIndex, String subFieldName) {
        return getShortValueInternal(fieldArrayIndex, getSubField(subFieldName));
    }

    protected Short getShortValueInternal(int fieldArrayIndex, SubField subField) {
        Object value = getValueInternal(fieldArrayIndex, subField);

        if (value == null) {
            return null;
        }

        return ((Number) value).shortValue();
    }

    public Integer[] getIntegerValues() {
        return getIntegerValues((SubField)null);
    }

    public Integer[] getIntegerValues(int subfieldIndex){
        return getIntegerValues(getSubField(subfieldIndex));
    }

    public Integer[] getIntegerValues(String subfieldName){
        return getIntegerValues(getSubField(subfieldName));
    }

    protected Integer[] getIntegerValues(SubField subfield){
        Integer[] rv = new Integer[getNumValues()];

        for(int i = 0; i < getNumValues(); i++){
            rv[i] = getIntegerValueInternal(i, subfield);
        }

        return rv;
    }

    public Integer getIntegerValue() {
        return getIntegerValueInternal(0, null);
    }

    public Integer getIntegerValue(int fieldArrayIndex) {
        return getIntegerValueInternal(fieldArrayIndex, null);
    }

    public Integer getIntegerValue(int fieldArrayIndex, int subFieldIndex) {
        return getIntegerValueInternal(fieldArrayIndex, getSubField(subFieldIndex));
    }

    public Integer getIntegerValue(int fieldArrayIndex, String subFieldName) {
        return getIntegerValueInternal(fieldArrayIndex, getSubField(subFieldName));
    }

    protected Integer getIntegerValueInternal(int fieldArrayIndex, SubField subField) {
        Object value = getValueInternal(fieldArrayIndex, subField);

        if (value == null) {
            return null;
        }

        return ((Number) value).intValue();
    }

    public Long[] getLongValues() {
        return getLongValues((SubField)null);
    }

    public Long[] getLongValues(int subfieldIndex){
        return getLongValues(getSubField(subfieldIndex));
    }

    public Long[] getLongValues(String subfieldName){
        return getLongValues(getSubField(subfieldName));
    }

    protected Long[] getLongValues(SubField subfield){
        Long[] rv = new Long[getNumValues()];

        for(int i = 0; i < getNumValues(); i++){
            rv[i] = getLongValueInternal(i, subfield);
        }

        return rv;
    }

    public Long getLongValue() {
        return getLongValueInternal(0, null);
    }

    public Long getLongValue(int fieldArrayIndex) {
        return getLongValueInternal(fieldArrayIndex, null);
    }

    public Long getLongValue(int fieldArrayIndex, int subFieldIndex) {
        return getLongValueInternal(fieldArrayIndex, getSubField(subFieldIndex));
    }

    public Long getLongValue(int fieldArrayIndex, String subFieldName) {
        return getLongValueInternal(fieldArrayIndex, getSubField(subFieldName));
    }

    protected Long getLongValueInternal(int fieldArrayIndex, SubField subField) {
        Object value = getValueInternal(fieldArrayIndex, subField);

        if (value == null) {
            return null;
        }

        return ((Number) value).longValue();
    }

    public Float[] getFloatValues() {
        return getFloatValues((SubField)null);
    }

    public Float[] getFloatValues(int subfieldIndex){
        return getFloatValues(getSubField(subfieldIndex));
    }

    public Float[] getFloatValues(String subfieldName){
        return getFloatValues(getSubField(subfieldName));
    }

    protected Float[] getFloatValues(SubField subfield){
        Float[] rv = new Float[getNumValues()];

        for(int i = 0; i < getNumValues(); i++){
            rv[i] = getFloatValueInternal(i, subfield);
        }

        return rv;
    }

    public Float getFloatValue() {
        return getFloatValueInternal(0, null);
    }

    public Float getFloatValue(int fieldArrayIndex) {
        return getFloatValueInternal(fieldArrayIndex, null);
    }

    public Float getFloatValue(int fieldArrayIndex, int subFieldIndex) {
        return getFloatValueInternal(fieldArrayIndex, getSubField(subFieldIndex));
    }

    public Float getFloatValue(int fieldArrayIndex, String subFieldName) {
        return getFloatValueInternal(fieldArrayIndex, getSubField(subFieldName));
    }

    protected Float getFloatValueInternal(int fieldArrayIndex, SubField subField) {
        Object value = getValueInternal(fieldArrayIndex, subField);

        if (value == null) {
            return null;
        }

        return new Float(((Number) value).doubleValue());
    }

    public Double[] getDoubleValues() {
        return getDoubleValues((SubField)null);
    }

    public Double[] getDoubleValues(int subfieldIndex){
        return getDoubleValues(getSubField(subfieldIndex));
    }

    public Double[] getDoubleValues(String subfieldName){
        return getDoubleValues(getSubField(subfieldName));
    }

    protected Double[] getDoubleValues(SubField subfield){
        Double[] rv = new Double[getNumValues()];

        for(int i = 0; i < getNumValues(); i++){
            rv[i] = getDoubleValueInternal(i, subfield);
        }

        return rv;
    }

    public Double getDoubleValue() {
        return getDoubleValueInternal(0, null);
    }

    public Double getDoubleValue(int fieldArrayIndex) {
        return getDoubleValueInternal(fieldArrayIndex, null);
    }

    public Double getDoubleValue(int fieldArrayIndex, int subFieldIndex) {
        return getDoubleValueInternal(fieldArrayIndex, getSubField(subFieldIndex));
    }

    public Double getDoubleValue(int fieldArrayIndex, String subFieldName) {
        return getDoubleValueInternal(fieldArrayIndex, getSubField(subFieldName));
    }

    protected Double getDoubleValueInternal(int fieldArrayIndex, SubField subField) {
        Object value = getValueInternal(fieldArrayIndex, subField);

        if (value == null) {
            return null;
        }

        return new Double(((Number) value).doubleValue());
    }

    public BigInteger[] getBigIntegerValues() {
        return getBigIntegerValues((SubField)null);
    }

    public BigInteger[] getBigIntegerValues(int subfieldIndex){
        return getBigIntegerValues(getSubField(subfieldIndex));
    }

    public BigInteger[] getBigIntegerValues(String subfieldName){
        return getBigIntegerValues(getSubField(subfieldName));
    }

    protected BigInteger[] getBigIntegerValues(SubField subfield){
        BigInteger[] rv = new BigInteger[getNumValues()];

        for(int i = 0; i < getNumValues(); i++){
            rv[i] = getBigIntegerValueInternal(i, subfield);
        }

        return rv;
    }

    public BigInteger getBigIntegerValue() {
        return getBigIntegerValueInternal(0, null);
    }

    public BigInteger getBigIntegerValue(int fieldArrayIndex) {
        return getBigIntegerValueInternal(fieldArrayIndex, null);
    }

    public BigInteger getBigIntegerValue(int fieldArrayIndex, int subFieldIndex) {
        return getBigIntegerValueInternal(fieldArrayIndex, getSubField(subFieldIndex));
    }

    public BigInteger getBigIntegerValue(int fieldArrayIndex, String subFieldName) {
        return getBigIntegerValueInternal(fieldArrayIndex, getSubField(subFieldName));
    }

    protected BigInteger getBigIntegerValueInternal(int fieldArrayIndex, SubField subField) {
        Object value = getValueInternal(fieldArrayIndex, subField);

        if (value == null) {
            return null;
        }

        return (BigInteger) value;
    }

    public String[] getStringValues() {
        return getStringValues((SubField)null);
    }

    public String[] getStringValues(int subfieldIndex){
        return getStringValues(getSubField(subfieldIndex));
    }

    public String[] getStringValues(String subfieldName){
        return getStringValues(getSubField(subfieldName));
    }

    protected String[] getStringValues(SubField subfield){
        String[] rv = new String[getNumValues()];

        for(int i = 0; i < getNumValues(); i++){
            rv[i] = getStringValueInternal(i, subfield);
        }

        return rv;
    }

    public String getStringValue() {
        return getStringValueInternal(0, null);
    }

    public String getStringValue(int fieldArrayIndex) {
        return getStringValueInternal(fieldArrayIndex, null);
    }

    public String getStringValue(int fieldArrayIndex, int subFieldIndex) {
        return getStringValueInternal(fieldArrayIndex, getSubField(subFieldIndex));
    }

    public String getStringValue(int fieldArrayIndex, String subFieldName) {
        return getStringValueInternal(fieldArrayIndex, getSubField(subFieldName));
    }

    protected String getStringValueInternal(int fieldArrayIndex, SubField subField) {
        Object value = getValueInternal(fieldArrayIndex, subField);
        int type = getTypeInternal(subField);

        if (value == null) {
            return null;
        }

        if(!forceShowInvalids && Fit.baseTypeInvalidMap.get(type).equals(value)) {
            return null;
        }

        return value.toString();
    }

    boolean read(InputStream in, int size) {
        try {
            DataInputStream data = new DataInputStream(in);
            if (getType() == Fit.BASE_TYPE_STRING) {
                try {
                    byte[] bytes = new byte[size];
                    in.read(bytes,0,size);
                    ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);

                    CharsetDecoder utf8Decoder = Charset.forName("UTF-8").newDecoder();
                    utf8Decoder.onMalformedInput(CodingErrorAction.IGNORE);
                    utf8Decoder.onUnmappableCharacter(CodingErrorAction.IGNORE);
                    CharBuffer decoded = utf8Decoder.decode(byteBuffer);
                    String[] strings = decoded.toString().split("\0");
                    Arrays.stream(strings).forEach(string -> values.add(string));

                } catch (java.io.IOException e) {
                    return true;
                }
            } else {
                int bytesLeft = size;
                boolean invalid = true;

                int type = getType();
                int baseTypeSize = Fit.baseTypeSizes[type & Fit.BASE_TYPE_NUM_MASK];
                Object invalidValue = Fit.baseTypeInvalidMap.get(type);

                while (bytesLeft > 0) {
                    Object value = null;
                    switch (type) {
                    case Fit.BASE_TYPE_ENUM:
                    case Fit.BASE_TYPE_UINT8:
                    case Fit.BASE_TYPE_UINT8Z: {
                        value = (short) (data.readByte() & 0xFF);
                        break;
                    }

                    case Fit.BASE_TYPE_SINT8: {
                        value = data.readByte();
                        break;
                    }

                    case Fit.BASE_TYPE_SINT16: {
                        value = data.readShort();
                        break;
                    }

                    case Fit.BASE_TYPE_UINT16:
                    case Fit.BASE_TYPE_UINT16Z: {
                        value = data.readByte() & 0xFF;
                        value = ((Integer)value) << 8;
                        value = ((Integer)value) | data.readByte() & 0xFF;
                        break;
                    }

                    case Fit.BASE_TYPE_SINT32: {
                        value = data.readInt();
                        break;
                    }

                    case Fit.BASE_TYPE_UINT32:
                    case Fit.BASE_TYPE_UINT32Z:
                    case Fit.BASE_TYPE_SINT64: {
                        value = (long) (data.readByte() & 0xFF);
                        for(int i = 1; i < baseTypeSize; i++) {
                            value = ((Long)value) << 8;
                            value = ((Long) value) | data.readByte() & 0xFF;
                        }

                        break;
                    }

                    case Fit.BASE_TYPE_FLOAT32: {
                        value = data.readFloat();
                        break;
                    }

                    case Fit.BASE_TYPE_FLOAT64: {
                        value = data.readDouble();
                        break;
                    }

                    case Fit.BASE_TYPE_BYTE: {
                        value = (short) (data.readByte() & 0xFF);
                        break;
                    }

                    case Fit.BASE_TYPE_UINT64:
                    case Fit.BASE_TYPE_UINT64Z: {
                        byte[] bytes = new byte[baseTypeSize];
                        data.read(bytes, 0, baseTypeSize);
                        value = new BigInteger(1, bytes);
                        break;
                    }

                    default:
                        return false;
                    }

                    if(value != null){
                        values.add(value);
                    }

                    if (!value.equals(invalidValue))
                        invalid = false;


                    bytesLeft -= Fit.baseTypeSizes[getType() & Fit.BASE_TYPE_NUM_MASK];
                }

                if (invalid && !forceShowInvalids) {
                    values.clear();
                }
            }
        } catch (java.io.IOException e) {
            return false;
        }

        return true;
    }

    protected void write(OutputStream out, FieldDefinitionBase fieldDef) {
        int bytesLeft = fieldDef.getSize() - getSize();

        write(out);

        // Fill remaining bytes with invalid.
        while (bytesLeft > 0) {
            writeValue(out, null);
            bytesLeft -= Fit.baseTypeSizes[getType() & Fit.BASE_TYPE_NUM_MASK];
        }
    }

    protected void write(OutputStream out) {
        for (Object value : values) {
            writeValue(out, value);
        }
    }

    private void writeValue(OutputStream out, Object value) {
        try {
            DataOutputStream data = new DataOutputStream(out);

            if (value == null) {
                switch (getType()) {
                case Fit.BASE_TYPE_ENUM:
                    data.writeByte(Fit.ENUM_INVALID);
                    break;
                case Fit.BASE_TYPE_UINT8:
                    data.writeByte(Fit.UINT8_INVALID);
                    break;
                case Fit.BASE_TYPE_UINT8Z:
                    data.writeByte(Fit.UINT8Z_INVALID);
                    break;
                case Fit.BASE_TYPE_SINT8:
                    data.writeByte(Fit.SINT8_INVALID);
                    break;
                case Fit.BASE_TYPE_BYTE:
                    data.writeByte(Fit.BYTE_INVALID);
                    break;
                case Fit.BASE_TYPE_SINT16:
                    data.writeShort(Fit.SINT16_INVALID);
                    break;
                case Fit.BASE_TYPE_UINT16:
                    data.writeShort(Fit.UINT16_INVALID);
                    break;
                case Fit.BASE_TYPE_UINT16Z:
                    data.writeShort(Fit.UINT16Z_INVALID);
                    break;
                case Fit.BASE_TYPE_SINT32:
                    data.writeInt(Fit.SINT32_INVALID);
                    break;
                case Fit.BASE_TYPE_UINT32:
                    data.writeInt((int)Fit.UINT32_INVALID.longValue());
                    break;
                case Fit.BASE_TYPE_UINT32Z:
                    data.writeInt((int)Fit.UINT32Z_INVALID.longValue());
                    break;
                case Fit.BASE_TYPE_SINT64:
                    data.writeLong(Fit.SINT64_INVALID);
                    break;
                case Fit.BASE_TYPE_UINT64:
                    data.writeLong(Fit.UINT64_INVALID.longValue());
                    break;
                case Fit.BASE_TYPE_UINT64Z:
                    data.writeLong(Fit.UINT64Z_INVALID.longValue());
                    break;
                case Fit.BASE_TYPE_STRING:
                    data.writeByte(0);
                    break;
                case Fit.BASE_TYPE_FLOAT32:
                    data.writeFloat(Fit.FLOAT32_INVALID);
                    break;
                case Fit.BASE_TYPE_FLOAT64:
                    data.writeDouble(Fit.FLOAT64_INVALID);
                    break;
                default:
                    break;
                }
            } else { // if (value != null)
                switch (getType()) {
                case Fit.BASE_TYPE_ENUM:
                case Fit.BASE_TYPE_UINT8:
                case Fit.BASE_TYPE_UINT8Z:
                case Fit.BASE_TYPE_SINT8:
                case Fit.BASE_TYPE_BYTE: {
                    if (value instanceof String) {
                        System.err.printf("Field.write(): Field %s value should not be string value %s\n", getFieldName(), value);
                    }
                    data.writeByte((int)Math.round(((Number) value).doubleValue()));
                    break;
                }

                case Fit.BASE_TYPE_SINT16:
                case Fit.BASE_TYPE_UINT16:
                case Fit.BASE_TYPE_UINT16Z: {
                    data.writeShort((int)Math.round(((Number) value).doubleValue()));
                    break;
                }

                case Fit.BASE_TYPE_SINT32:
                case Fit.BASE_TYPE_UINT32:
                case Fit.BASE_TYPE_UINT32Z: {
                    data.writeInt((int)Math.round(((Number) value).doubleValue()));
                    break;
                }

                case Fit.BASE_TYPE_STRING: {
                    OutputStreamWriter stringWriter = new OutputStreamWriter(out, "UTF-8");
                    stringWriter.write(value.toString());
                    stringWriter.flush();
                    out.write(0);
                    break;
                }

                case Fit.BASE_TYPE_FLOAT32: {
                    data.writeFloat(((Number) value).floatValue());
                    break;
                }

                case Fit.BASE_TYPE_FLOAT64: {
                    data.writeDouble(((Number) value).doubleValue());
                    break;
                }

                case Fit.BASE_TYPE_SINT64:
                case Fit.BASE_TYPE_UINT64:
                case Fit.BASE_TYPE_UINT64Z: {
                    data.writeLong(((Number) value).longValue());
                    break;
                }

                default:
                    break;
                }
            } // if (value != null)
        } catch (java.io.IOException e) {
        }
    }
}
