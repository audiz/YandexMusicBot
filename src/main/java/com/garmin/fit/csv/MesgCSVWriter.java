////////////////////////////////////////////////////////////////////////////////
// The following FIT Protocol software provided may be used with FIT protocol
// devices only and remains the copyrighted property of Garmin Canada Inc.
// The software is being provided on an "as-is" basis and as an accommodation,
// and therefore all warranties, representations, or guarantees of any kind
// (whether express, implied or statutory) including, without limitation,
// warranties of merchantability, non-infringement, or fitness for a particular
// purpose, are specifically disclaimed.
//
// Copyright 2021 Garmin Canada Inc.
////////////////////////////////////////////////////////////////////////////////
// ****WARNING****  This file is auto-generated!  Do NOT edit this file.
// Profile Version = 21.53Release
// Tag = production/akw/21.53.00-0-g1b82aa2b
////////////////////////////////////////////////////////////////////////////////


package com.garmin.fit.csv;

import com.garmin.fit.*;

import java.util.Collection;
import java.util.Iterator;

public class MesgCSVWriter extends MesgCSVWriterBase implements MesgListener, MesgDefinitionListener {
    private int numUnknownMesgs = 0;
    private int numUnknownFields = 0;
    private boolean dataInCsv;

    public MesgCSVWriter(String fileName) {
        super(fileName);
        dataInCsv = false;
    }

    public void close() {
        csv.close();
    }

    public void hideUnknownData() {
        hideUnknownData = true;
    }

    public int getNumUnknownMesgs() {
        return numUnknownMesgs;
    }

    public int getNumUnknownFields() {
        return numUnknownFields;
    }

    public void onMesgDefinition(MesgDefinition mesgDef) {
        Collection<FieldDefinition> fields = mesgDef.getFields();
        int headerNum;
        Mesg mesg = Factory.createMesg(mesgDef.getNum());
        if ((hideUnknownData) && ((mesg == null) || mesg.getName().equals("unknown"))) {
            return;
        }

        csv.clear();
        csv.set("Type", "Definition");
        csv.set("Local Number", mesgDef.getLocalNum());

        if (mesg == null) {
            csv.set("Message", "unknown");
        } else {
            csv.set("Message", mesg.getName());
        }

        headerNum = 0;

        for (FieldDefinition fieldDef : fields) {
            Field field = Factory.createField(mesgDef.getNum(), fieldDef.getNum());
            if ((hideUnknownData) && ((field == null) || (field.getName().equals("unknown")))) {
                numUnknownFields++;
                continue;
            }

            headerNum++;

            if (field == null) {
                csv.set("Field " + headerNum, "unknown");
            } else {
                csv.set("Field " + headerNum, field.getName());
            }

            csv.set("Value " + headerNum, fieldDef.getSize() / Fit.baseTypeSizes[fieldDef.getType() & Fit.BASE_TYPE_NUM_MASK]);
            csv.set("Units " + headerNum, "");
        }

        for (DeveloperFieldDefinition fieldDef : mesgDef.getDeveloperFields()) {
            if (hideUnknownData && !fieldDef.isDefined()) {
                numUnknownFields++;
                continue;
            }

            headerNum++;

            if (!fieldDef.isDefined()) {
                csv.set("Field " + headerNum, "undefined-dev-data");
            } else {
                csv.set("Field " + headerNum, fieldDef.getFieldName());
            }

            csv.set("Value " + headerNum, fieldDef.getSize() / Fit.baseTypeSizes[fieldDef.getType() & Fit.BASE_TYPE_NUM_MASK]);
            csv.set("Units " + headerNum, "");
        }

        csv.writeln();
        dataInCsv = true;
    }

    public void onMesg(Mesg mesg) {
        Collection<Field> fields = mesg.getFields();
        int headerNum;

        if ((mesg.getName().equals("unknown")) && (hideUnknownData)) {
            numUnknownMesgs++;
            return;
        }

        csv.clear();
        csv.set("Type", "Data");
        csv.set("Local Number", mesg.getLocalNum());
        csv.set("Message", mesg.getName());

        if (removeExpandedFields) {
            mesg.removeExpandedFields();
        }

        headerNum = 0;

        for (Field field : fields) {
            int subFieldIndex = mesg.getActiveSubFieldIndex(field.getNum());

            if (((field.getName().equals("unknown")) && (hideUnknownData))){
                continue;
            }

            headerNum++;

            csv.set("Field " + headerNum, field.getName(subFieldIndex));

            String value = getValueString(field, subFieldIndex);

            csv.set("Value " + headerNum, value);
            csv.set("Units " + headerNum, field.getUnits(subFieldIndex));
        }

        for (DeveloperField field : mesg.getDeveloperFields()){
            if(!field.isDefined() && hideUnknownData){
                continue;
            }

            headerNum++;

            csv.set("Field " + headerNum, field.getName());
            String value = getValueString(field, Fit.SUBFIELD_INDEX_MAIN_FIELD);

            csv.set("Value " + headerNum, value);
            csv.set("Units " + headerNum, field.getUnits());
        }

        csv.writeln();
        dataInCsv = true;
    }

    public boolean csvHasData() {
        return dataInCsv;
    }
}
