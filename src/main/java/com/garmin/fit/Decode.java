////////////////////////////////////////////////////////////////////////////////
// The following FIT Protocol software provided may be used with FIT protocol
// devices only and remains the copyrighted property of Garmin Canada Inc.
// The software is being provided on an "as-is" basis and as an accommodation,
// and therefore all warranties, representations, or guarantees of any kind
// (whether express, implied or statutory) including, without limitation,
// warranties of merchantability, non-infringement, or fitness for a particular
// purpose, are specifically disclaimed.
//
// Copyright 2021 Garmin Canada Inc.
////////////////////////////////////////////////////////////////////////////////
// ****WARNING****  This file is auto-generated!  Do NOT edit this file.
// Profile Version = 21.53Release
// Tag = production/akw/21.53.00-0-g1b82aa2b
////////////////////////////////////////////////////////////////////////////////


package com.garmin.fit;

import java.util.ArrayList;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;

/**
 * Decodes binary to java objects.
 *
 */
@SuppressWarnings("overloads")
public class Decode {
    // Public Variables
    public enum RETURN {
        CONTINUE, MESG, MESG_DEF, END_OF_FILE
    }

    // Private Variables
    private enum STATE {
        FILE_HDR,
        RECORD,
        RESERVED1,
        ARCH,
        MESG_NUM_0,
        MESG_NUM_1,
        NUM_FIELDS,
        FIELD_NUM,
        FIELD_SIZE,
        FIELD_TYPE,
        NUM_DEV_FIELDS,
        DEV_FIELD_NUM,
        DEV_FIELD_SIZE,
        DEV_FIELD_DEV_ID,
        FIELD_DATA,
        DEV_FIELD_DATA,
        FILE_CRC_HIGH
    }

    private class AccumulatedField {
        int mesgNum;
        int destFieldNum; //Field# to accumulate into
        long lastValue;
        long accumulatedValue;

        AccumulatedField(int mesgNum, int destFieldNum) {
            this.mesgNum = mesgNum;
            this.destFieldNum = destFieldNum;
            this.lastValue = 0;
            this.accumulatedValue = 0;
        }

        public long accumulate(long value, int bits) {
            long mask = ((long) 1 << bits) - 1;

            accumulatedValue += (value - lastValue) & mask;
            lastValue = value;

            return accumulatedValue;
        }

        public long set(long value) {
            accumulatedValue = value;
            this.lastValue = value;
            return accumulatedValue;
        }
    }

    private class Accumulator {
        // Index by Mesg# and DestField#
        ArrayList<AccumulatedField> accumulatedFields;

        Accumulator() {
            accumulatedFields = new ArrayList<AccumulatedField>();
        }

        public void set(int mesgNum, int destFieldNum, long value) {
            AccumulatedField accumField = null;
            int i;

            for (i = 0; i < accumulatedFields.size(); i++) {
                accumField = accumulatedFields.get(i);

                if ((accumField.mesgNum == mesgNum) && (accumField.destFieldNum == destFieldNum)) {
                    break;
                }
            }

            if (i == accumulatedFields.size()) {
                accumField = new AccumulatedField(mesgNum, destFieldNum);
                accumulatedFields.add(accumField);
            }

            accumField.set(value);
        }

        public long accumulate(int mesgNum, int destFieldNum, long value, int bits) {
            AccumulatedField accumField = null;
            int i;

            for (i = 0; i < accumulatedFields.size(); i++) {
                accumField = accumulatedFields.get(i);

                if ((accumField.mesgNum == mesgNum) && (accumField.destFieldNum == destFieldNum)) {
                    break;
                }
            }

            if (i == accumulatedFields.size()) {
                accumField = new AccumulatedField(mesgNum, destFieldNum);
                accumulatedFields.add(accumField);
            }

            return accumField.accumulate(value, bits);

        }
    }

    private static final long DECODE_DATA_RECORDS_ONLY = Long.MAX_VALUE;
    private static final int FIT_PROTOCOL_VERSION_ONE = 1;
    private static final int FIT_HEADER_SIZE_WITH_CRC = 14;
    private static final int FIT_HEADER_SIZE_NO_CRC = 12;
    private static boolean invalidDataSize = false;
    private boolean hasDevData;
    private static final int BUFFER_SIZE = 512;
    private STATE state;
    private byte fileHdrOffset;
    private byte fileHdrSize;
    private long fileDataSize;
    private long fileBytesLeft;
    private int crc;
    private Mesg mesg;
    private int localMesgIndex;
    private MesgDefinition localMesgDefs[] = new MesgDefinition[Fit.MAX_LOCAL_MESGS];
    private HashMap<Short, DeveloperDataIdMesg> developerDataIds = new HashMap<Short, DeveloperDataIdMesg>();
    private HashMap<Short, HashMap<Short, FieldDescriptionMesg>> developerFields = new HashMap<Short, HashMap<Short, FieldDescriptionMesg>>();

    private int numFields;
    private int fieldIndex;
    private int fieldDataIndex;
    private int fieldBytesLeft;
    private byte fieldData[] = new byte[Fit.MAX_FIELD_SIZE];
    private int lastTimeOffset;
    private long timestamp;
    private long systemTimeOffset;
    private Accumulator accumulator = new Accumulator();
    private boolean pause;
    private InputStream in;
    private boolean instreamIsComplete;
    private boolean invalidFileDataSize = false;
    private String headerException;
    private int currentByteOffset = 0;

    private ArrayList<MesgListener> mesgListeners = new ArrayList<MesgListener>();
    private ArrayList<MesgDefinitionListener> mesgDefListeners = new ArrayList<MesgDefinitionListener>();
    private ArrayList<DeveloperFieldDescriptionListener> devFieldDescListeners = new ArrayList<DeveloperFieldDescriptionListener>();

    private int bytesRead;
    private int currentByteIndex;
    private byte[] buffer;

    public Decode() {
        systemTimeOffset = 0;
        instreamIsComplete = true;
        nextFile();
        bytesRead = 0;
        currentByteIndex = 0;
        buffer = new byte[BUFFER_SIZE];
        if (Fit.debug) {
            System.out.printf("Fit.Decode: Starting decode...\n");
        }
    }

    /**
     * Gets the property that indicates that the file has an invalid data size
     *
     * @return true if file has an invalid data size
     */
    public boolean getInvalidFileDataSize() {
        return invalidFileDataSize;
    }

    /**
     * Sets the Invalid Data size Property (so that it can be reset)
     *
     * @param value
     *           boolean value to set
     */
    public void setInvalidFileDataSize(boolean value) {
        invalidFileDataSize = value;
    }

    public void nextFile() {
        // Only reset the decoder if we have the entire chained file
        if (instreamIsComplete == true) {
            fileBytesLeft = 3; // Header byte + CRC.
            fileHdrOffset = 0;
            crc = 0;
            state = STATE.FILE_HDR;
            lastTimeOffset = 0;
            pause = false;
            invalidDataSize = false;
            invalidFileDataSize = false;
            headerException = null;
        }
    }

    public void addListener(MesgListener mesgListener) {
        if ((mesgListener != null) && !mesgListeners.contains(mesgListener)) {
            mesgListeners.add(mesgListener);
        }
    }

    public void addListener(MesgDefinitionListener mesgDefinitionListener) {
        if ((mesgDefinitionListener != null) && !mesgDefListeners.contains(mesgDefinitionListener)) {
            mesgDefListeners.add(mesgDefinitionListener);
        }
    }

    public void addListener(DeveloperFieldDescriptionListener listener) {
        if ((listener != null) && !devFieldDescListeners.contains(listener)) {
            devFieldDescListeners.add(listener);
        }
    }

    public void setSystemTimeOffset(long systemTimeOffset) {
        this.systemTimeOffset = systemTimeOffset;
    }

    /**
     * Override the default read behaviour by skipping header decode.
     * CRC checking is not possible since the datasize is unknown.
     * Decode continues until EOF is encountered or a decode
     * error occurs.
     * May only be called prior to calling read().
     * Can be combined with incompleteStream() option.
     */
    public void skipHeader()
    {

        // Do not allow changing the settings after read has started
        if (in != null)
            {
                throw new FitRuntimeException("Can't set skipHeader option after Decode started!");
            }
        // Skip header decode
        state = STATE.RECORD;
        // Decode until we hit EOF, don't consider CRC
        fileBytesLeft = DECODE_DATA_RECORDS_ONLY;
    }

    /**
     * Override the default read behaviour allowing decode of partial streams.
     * If EOF is encountered no exception is raised.  Caller may choose to
     * call resume() possibly after more bytes have arrived in the stream.
     * May only be set prior to first calling read().
     *
     */
    public void incompleteStream()
    {
        // Do not allow changing the settings after read has started
        if (in != null) {
            throw new FitRuntimeException("Can't set incompleteStream option after Decode started!");
        }
        // Don't raise an error if eof is encountered during decode,
        // caller may try to resume if more bytes arrive
        this.instreamIsComplete = false;
    }

    /**
     * Allow for invalid values in messages. Can override setting
     * implied by Fit.ENABLE_LEGACY_BEHAVIOUR. Should only be used by
     * CSV tool to allow for override at the application level. If this
     * behaviour is desired by default, Fit.ENABLE_LEGACY_BEHAVIOUR should
     * be modified instead. Can only be called before calling resume().
     *
     */
    public void showInvalidValues() {
        // Do not allow changing the settings after read has started
        if (in != null) {
            throw new FitRuntimeException("Can't set showInvalidValues option after Decode started!");
        }

        FieldBase.forceShowInvalids = true;
    }

    /**
     * Reads a FIT binary file.
     *
     * @param in
     *           file input stream
     * @param mesgListener
     *           message listener
     * @param mesgDefListener
     *           message definition listener
     * @return true if finished reading file
     */
    public boolean read(final InputStream in, final MesgListener mesgListener, final MesgDefinitionListener mesgDefListener) {
        boolean status = true;
        addListener(mesgListener);
        addListener(mesgDefListener);
        currentByteOffset = 0;
        try {
            while ( ( bytesAvailable(in) ) && (status) ) { // try to read a file while more data is available.
                status = read(in, mesgListener);
                nextFile();
            }
        } catch (java.io.IOException e) {
            throw new FitRuntimeException(e);
        }

        return status;
    }

    /**
     * Reads a FIT binary file.
     *
     * @param in
     *           file input stream
     * @param mesgListener
     *           message listener
     * @return true if finished reading file
     */
    public boolean read(final InputStream in, final MesgListener mesgListener) {
        addListener(mesgListener);
        return read(in);
    }

    public boolean read(final InputStream in) {
        this.in = in;
        return resume();
    }

    public void pause() {
        pause = true;
    }

    /**
     * Resumes reading the file.
     *
     * @return true if finished reading file
     */
    public boolean resume() {
        pause = false;
        Decode.RETURN decodeReturn = RETURN.CONTINUE;

        try {
            do {
                if (pause) {
                    return false;
                }

                for ( ; currentByteIndex < bytesRead; currentByteIndex++ ) {
                    decodeReturn = read(buffer[currentByteIndex]);

                    switch (decodeReturn) {
                    case CONTINUE:
                        break;

                    case MESG:
                        switch (mesg.num) {
                        case MesgNum.DEVELOPER_DATA_ID: {
                            DeveloperDataIdMesg devIdMesg = new DeveloperDataIdMesg(mesg);
                            short index = devIdMesg.getDeveloperDataIndex();
                            developerDataIds.put(index, devIdMesg);
                            developerFields.put(index, new HashMap<Short, FieldDescriptionMesg>());
                            break;
                        }

                        case MesgNum.FIELD_DESCRIPTION: {
                            FieldDescriptionMesg fieldDescriptionMesg = new FieldDescriptionMesg(mesg);
                            short index = fieldDescriptionMesg.getDeveloperDataIndex();
                            if (developerFields.containsKey(index)) {
                                developerFields.get(index)
                                    .put(fieldDescriptionMesg.getFieldDefinitionNumber(), fieldDescriptionMesg);

                                DeveloperFieldDescription description = new DeveloperFieldDescription(developerDataIds.get(index), fieldDescriptionMesg);
                                for(DeveloperFieldDescriptionListener listener : devFieldDescListeners) {
                                    listener.onDescription(description);
                                }
                            }
                            break;
                        }
                        }
                        for (MesgListener mesgListener : mesgListeners) {
                            mesgListener.onMesg(mesg);
                        }
                        break;

                    case MESG_DEF:
                        for (MesgDefinitionListener mesgDefListener : mesgDefListeners) {
                            mesgDefListener.onMesgDefinition(localMesgDefs[localMesgIndex]);
                        }
                        break;

                    case END_OF_FILE:
                        // Increment so we do not read the same byte twice in the case of a chained file
                        currentByteIndex++;
                        currentByteOffset++;
                        return true;

                    default:
                        currentByteOffset++;
                        throw new FitRuntimeException("FIT decode error: " + decodeReturn + " at byte: " + currentByteOffset);
                    }
                    // Increment offset from the start of the file to get byte location for error reporting
                    currentByteOffset++;
                }
                currentByteIndex = 0;
            } while ((bytesRead = in.read(buffer, 0, buffer.length)) >= 0);
        } catch (java.io.IOException e) {
            throw new FitRuntimeException(e);
        }

        if ((instreamIsComplete == true) && (fileBytesLeft != DECODE_DATA_RECORDS_ONLY)) {
            // When decoding a complete file we should exit via END_OF_FILE state only
            throw new FitRuntimeException("FIT decode error: Unexpected end of input stream at byte: " + currentByteOffset);
        }
        if (instreamIsComplete == false) {
            // If stream is not yet complete caller can resume() when there is more data
            // or decide there was an error.
            if ((decodeReturn == RETURN.MESG) || (decodeReturn == RETURN.MESG_DEF)) {
                // Our stream ended on a complete message, maybe we are done decoding
                return true;
            } else {
                // EOF was encountered mid message.  Caller may want to resume once
                // more bytes are available.
                return false;
            }
        }
        // if Decoding Records section only, file should end on a complete message
        // (unless incomplete stream option above was also used)
        else {
            if ((decodeReturn == RETURN.MESG) || (decodeReturn == RETURN.MESG_DEF)) {
                // Our stream ended on a complete message, we are done decoding
                return true;
            } else {
                if ((!invalidDataSize) || (!invalidFileDataSize)) {
                    throw new FitRuntimeException("FIT decode error: Unexpected end of input stream at byte: " + currentByteOffset);
                } else {
                    return true;
                }
            }
        }
    }

    /**
     * Reads the header to determine if the file is FIT.
     *
     * @param in
     *           file input stream
     *
     * @return true if file is FIT
     */
    public boolean isFileFit(final InputStream in) {

        try {
            do {
                for ( ; currentByteIndex < bytesRead; currentByteIndex++ ) {
                    switch (this.read(buffer[currentByteIndex])) {
                    case CONTINUE:
                    case MESG:
                    case MESG_DEF:
                        break;

                    case END_OF_FILE:
                        return true;

                    default:
                        return false;
                    }

                    if (this.state != STATE.FILE_HDR) {
                        return true;
                    }
                }
                currentByteIndex = 0;
            } while ((bytesRead = in.read(buffer, 0, buffer.length)) >= 0);
        } catch (java.io.IOException e) {
            throw new FitRuntimeException(e);
        } catch (FitRuntimeException e) {
            // Fall through and return as not FIT after resetting buffer state.
            bytesRead = 0;
            currentByteIndex = 0;
        }

        return false;
    }

    /**
     * Reads the FIT binary file header and crc to check compatibility and integrity.
     *
     * @param in
     *           file input stream
     *
     * @return true if file is ok (not corrupt)
     */
    public boolean checkFileIntegrity(final InputStream in) {
        boolean status = true;

        try {
            do {
                for ( ; currentByteIndex < bytesRead; currentByteIndex++ ) {
                    switch (this.read(buffer[currentByteIndex])) {
                    case CONTINUE:
                    case MESG:
                    case MESG_DEF:
                        break;

                    case END_OF_FILE:
                        this.nextFile();
                        break;

                    default:
                        status = false;
                        break;
                    }
                }
                currentByteIndex = 0;
            } while ((bytesRead = in.read(buffer, 0, buffer.length)) >= 0);
        } catch (java.io.IOException e) {
            throw new FitRuntimeException(e);
        } catch (FitRuntimeException e) {
            // Fall through and return integrity failure.
            status = false;
            //If we hit the case where invalid data size, reset file state.
            if( getInvalidFileDataSize() ) {
                nextFile();
            }
            // Reset buffer state.
            bytesRead = 0;
            currentByteIndex = 0;
        }

        return status;
    }

    public RETURN read(byte data) {
        if (Fit.debug) {
            if (fileBytesLeft == 2) {
                System.out.printf("Fit.Decode: Expecting next 2 bytes to be end of file CRC = 0x%04X\n", crc);
            }
            System.out.printf("Fit.Decode: 0x%02X - %s\n", data & 0xFF, state.toString());
        }

        // Only check crc for source files with header/footer
        if ((fileBytesLeft > 0) && (fileBytesLeft != DECODE_DATA_RECORDS_ONLY)) {
            crc = CRC.get16(crc, data);

            fileBytesLeft--;

            if ( ( fileBytesLeft == 1 ) && ( state.ordinal() > STATE.FILE_HDR.ordinal() ) ) { // CRC low byte.
                if (state != STATE.RECORD) {
                    throw new FitRuntimeException("FIT decode error: Decoder not in correct state after last data byte in file.  Check message definitions. Error at byte: " + currentByteOffset);
                }

                return RETURN.CONTINUE; // Next byte.
            } else if ( ( fileBytesLeft == 0 ) && ( state.ordinal() > STATE.FILE_HDR.ordinal() ) ) { // CRC high byte.
                if (crc != 0) {
                    throw new FitRuntimeException("FIT decode error: File CRC failed. Error at byte: " + currentByteOffset);
                }

                return RETURN.END_OF_FILE;
            }
        }

        switch (state) {
        case FILE_HDR:
            switch (fileHdrOffset++) {
            case 0:
                if( data == 0 )
                {
                    fileBytesLeft += 1;
                    fileHdrOffset = 0;
                    headerException = null;
                    crc = 0;
                }
                else if( data < FIT_HEADER_SIZE_NO_CRC )
                {
                    headerException = "FIT decode error: Header size is invalid. Error at byte: " + currentByteOffset;
                }
                else
                {
                    fileHdrSize = data;
                    fileBytesLeft = fileHdrSize + 2;
                }
                break;
            case 1:
                if ((data & Fit.PROTOCOL_VERSION_MAJOR_MASK) > (Fit.PROTOCOL_VERSION_MAJOR << Fit.PROTOCOL_VERSION_MAJOR_SHIFT)) {
                    headerException = "FIT decode error: Protocol version " + ((data & Fit.PROTOCOL_VERSION_MAJOR_MASK) >> Fit.PROTOCOL_VERSION_MAJOR_SHIFT) + "." + (data & Fit.PROTOCOL_VERSION_MINOR_MASK) + " not supported.  Must be " + Fit.PROTOCOL_VERSION_MAJOR + "." + Fit.PROTOCOL_VERSION_MINOR + " or earlier.";
                }
                break;
            case 4:
                fileDataSize = data & 0xFF;
                break;
            case 5:
                fileDataSize |= (long) (data & 0xFF) << 8;
                break;
            case 6:
                fileDataSize |= (long) (data & 0xFF) << 16;
                break;
            case 7:
                fileDataSize |= (long) (data & 0xFF) << 24;
                // Check file size
                if ( (fileDataSize == 0) && ( (!invalidDataSize) || (!invalidFileDataSize) ) ) {
                    invalidDataSize = true;
                    invalidFileDataSize = true;
                    headerException = "FIT decode error: File Size is 0. Error at byte: " + currentByteOffset;
                }
                break;
            case 8:
                if (data != '.') {
                    headerException = "FIT decode error: File is not FIT format.  Check file header data type. Error at byte: " + currentByteOffset;
                }
                break;
            case 9:
                if (data != 'F') {
                    headerException = "FIT decode error: File is not FIT format.  Check file header data type. Error at byte: " + currentByteOffset;
                }
                break;
            case 10:
                if (data != 'I') {
                    headerException = "FIT decode error: File is not FIT format.  Check file header data type. Error at byte: " + currentByteOffset;
                }
                break;
            case 11:
                if (data != 'T') {
                    headerException = "FIT decode error: File is not FIT format.  Check file header data type. Error at byte: " + currentByteOffset;
                }
                if ((headerException != null) && (fileHdrSize == FIT_HEADER_SIZE_NO_CRC)) {
                    throw new FitRuntimeException(headerException);
                }
                break;
            case 12:
                // CRC byte 1
                break;
            case 13:
                // CRC byte 2
                if (headerException != null) {
                    // Error at current byte, increment index so we do not attempt to decode it again.
                    currentByteIndex++;
                    throw new FitRuntimeException(headerException);
                }
                break;
            default:
                break;
            }

            if ((fileHdrOffset == fileHdrSize) && (fileHdrSize != 0)) {
                // We don't care about the CRC when the file size is invalid
                if ((invalidDataSize) && (invalidFileDataSize)) {
                    fileBytesLeft = DECODE_DATA_RECORDS_ONLY;
                } else {
                    fileBytesLeft = fileDataSize + 2; // include crc
                }
                state = STATE.RECORD;
            }
            break;

        case RECORD:
            fieldIndex = 0;
            fieldBytesLeft = 0;

            if (fileBytesLeft > 1) {
                if ((data & Fit.HDR_TIME_REC_BIT) != 0) {
                    Field timestampField;
                    int timeOffset = data & Fit.HDR_TIME_OFFSET_MASK;

                    localMesgIndex = (data & Fit.HDR_TIME_TYPE_MASK) >> Fit.HDR_TIME_TYPE_SHIFT;

                    if (localMesgDefs[localMesgIndex] == null) {
                        throw new FitRuntimeException("FIT decode error: Missing message definition for local message number " + localMesgIndex + ". Error at byte: " + currentByteOffset);
                    }
                    timestampField = Factory.createField(localMesgDefs[localMesgIndex].num, Fit.FIELD_NUM_TIMESTAMP);
                    timestamp += (timeOffset - lastTimeOffset) & Fit.HDR_TIME_OFFSET_MASK;
                    lastTimeOffset = timeOffset;
                    timestampField.setValue(timestamp);

                    mesg = Factory.createMesg(localMesgDefs[localMesgIndex].num);
                    mesg.localNum = localMesgIndex;
                    mesg.systemTimeOffset = systemTimeOffset;
                    mesg.addField(timestampField);

                    // Determine where to go next
                    if (localMesgDefs[localMesgIndex].fields.size() != 0) {
                        // There is native data to parse
                        state = STATE.FIELD_DATA;
                    } else if (localMesgDefs[localMesgIndex].getDeveloperFieldTotalSize() > 0) {
                        // There is no native data to parse but there are developer fields
                        state = STATE.DEV_FIELD_DATA;
                    } else {
                        // There is no data to parse return the message
                        return RETURN.MESG;
                    }
                } else {
                    localMesgIndex = data & Fit.HDR_TYPE_MASK;

                    if ((data & Fit.HDR_TYPE_DEF_BIT) != 0) {
                        localMesgDefs[localMesgIndex] = new MesgDefinition();
                        localMesgDefs[localMesgIndex].localNum = localMesgIndex;
                        hasDevData = false;

                        if((data & Fit.HDR_DEV_FIELDS_BIT) != 0) {
                            // There is Developer Data in this Header
                            hasDevData = true;
                        }

                        state = STATE.RESERVED1;
                    } else {
                        if (localMesgDefs[localMesgIndex] == null)
                            throw new FitRuntimeException("FIT decode error: Missing message definition for local message number " + localMesgIndex + ". Error at byte: " + currentByteOffset);

                        mesg = Factory.createMesg(localMesgDefs[localMesgIndex].num);
                        mesg.localNum = localMesgIndex;
                        mesg.systemTimeOffset = systemTimeOffset;

                        // Determine where to go next
                        if (localMesgDefs[localMesgIndex].fields.size() != 0) {
                            // There is native data to parse
                            state = STATE.FIELD_DATA;
                        } else if (localMesgDefs[localMesgIndex].getDeveloperFieldTotalSize() > 0) {
                            // There is no native data to parse but there are developer fields
                            state = STATE.DEV_FIELD_DATA;
                        } else {
                            // There is no data to parse return the message
                            return RETURN.MESG;
                        }
                    }
                }
            } else {
                // We just got the low byte of the crc.
                state = STATE.FILE_CRC_HIGH;
            }
            break;

        case RESERVED1:
            state = STATE.ARCH;
            break;

        case ARCH:
            localMesgDefs[localMesgIndex].arch = ((int) data & 0xFF);
            state = STATE.MESG_NUM_0;
            break;

        case MESG_NUM_0:
            // Read the global message number bytes in as if they are in little
            // endian format.
            localMesgDefs[localMesgIndex].num = ((int) data & 0xFF);
            state = STATE.MESG_NUM_1;
            break;

        case MESG_NUM_1:
            localMesgDefs[localMesgIndex].num |= (((int) data & 0xFF) << 8);

            // We have to check for endianness.
            if (localMesgDefs[localMesgIndex].arch == Fit.ARCH_ENDIAN_BIG) {
                localMesgDefs[localMesgIndex].num = (localMesgDefs[localMesgIndex].num >> 8) | ((localMesgDefs[localMesgIndex].num & 0xFF) << 8);
            } else if (localMesgDefs[localMesgIndex].arch != Fit.ARCH_ENDIAN_LITTLE) {
                throw new FitRuntimeException("FIT decode error: Endian " + localMesgDefs[localMesgIndex].arch + " not supported. Error at byte: " + currentByteOffset);
            }

            state = STATE.NUM_FIELDS;
            break;

        case NUM_FIELDS:
            numFields = ((int) data & 0xFF);

            if (numFields == 0) {
                if (hasDevData) {
                    state = STATE.NUM_DEV_FIELDS;
                } else {
                    state = STATE.RECORD;
                    return RETURN.MESG_DEF;
                }
            } else {
                state = STATE.FIELD_NUM;
            }

            break;

        case FIELD_NUM:
            localMesgDefs[localMesgIndex].fields.add(new FieldDefinition());
            localMesgDefs[localMesgIndex].fields.get(fieldIndex).num = ((int) data & 0xFF);
            state = STATE.FIELD_SIZE;
            break;

        case FIELD_SIZE:
            localMesgDefs[localMesgIndex].fields.get(fieldIndex).size = ((int) data & 0xFF);
            state = STATE.FIELD_TYPE;
            break;

        case FIELD_TYPE:
            localMesgDefs[localMesgIndex].fields.get(fieldIndex).type = ((int) data & 0xFF);

            if (++fieldIndex >= numFields) {
                if (hasDevData) {
                    state = STATE.NUM_DEV_FIELDS;
                } else {
                    state = STATE.RECORD;
                    return RETURN.MESG_DEF;
                }
            } else {
                state = STATE.FIELD_NUM;
            }
            break;

        case NUM_DEV_FIELDS:
            fieldIndex = 0;
            numFields = ((int)data & 0xFF);

            if(numFields == 0) {
                state = STATE.RECORD;
                return RETURN.MESG_DEF;
            }

            state = STATE.DEV_FIELD_NUM;
            break;

        case DEV_FIELD_NUM:
            localMesgDefs[localMesgIndex].developerFields.add(new DeveloperFieldDefinition());
            localMesgDefs[localMesgIndex].developerFields.get(fieldIndex).setNum((short)(data & 0xFF));
            state = STATE.DEV_FIELD_SIZE;
            break;

        case DEV_FIELD_SIZE:
            localMesgDefs[localMesgIndex].developerFields.get(fieldIndex).setSize((int) data & 0xFF);
            state = STATE.DEV_FIELD_DEV_ID;
            break;

        case DEV_FIELD_DEV_ID:
            DeveloperFieldDefinition fieldDefinition = localMesgDefs[localMesgIndex].developerFields.get(fieldIndex);
            short castedData = (short)data;
            if(developerFields.containsKey(castedData)) {
                // There is a Developer ID Message for this Field
                fieldDefinition.setDeveloperDataIdMesg(developerDataIds.get(castedData));

                if(developerFields.get(castedData).containsKey(fieldDefinition.getNum())) {
                    // The Developer has Defined this field number
                    FieldDescriptionMesg fieldDescription = developerFields.get(castedData).get(fieldDefinition.getNum());
                    fieldDefinition.setFieldDescription(fieldDescription);
                }
            }

            if (++fieldIndex >= numFields) {
                state = STATE.RECORD;
                return RETURN.MESG_DEF;
            } else {
                state = STATE.DEV_FIELD_NUM;
            }
            break;

        case FIELD_DATA: {
            FieldDefinition fieldDef = localMesgDefs[localMesgIndex].fields.get(fieldIndex);

            while (fieldBytesLeft == 0) {
                fieldDataIndex = 0;
                fieldBytesLeft = fieldDef.size;

                if (fieldBytesLeft == 0) {
                    if ((fieldIndex + 1) >= localMesgDefs[localMesgIndex].fields.size()) {
                        break;
                    }
                    fieldDef = localMesgDefs[localMesgIndex].fields.get(++fieldIndex);
                }
            }

            fieldData[fieldDataIndex++] = data;
            fieldBytesLeft--;

            if (fieldBytesLeft == 0) {
                Field field;
                int typeSize;
                int elements;
                boolean read = true;

                if ((fieldDef.type & Fit.BASE_TYPE_NUM_MASK) < Fit.BASE_TYPES) { // Ignore field if base type not supported.
                    typeSize = Fit.baseTypeSizes[(fieldDef.type & Fit.BASE_TYPE_NUM_MASK)];
                    elements = fieldDef.size / typeSize;

                    if (((fieldDef.type & Fit.BASE_TYPE_ENDIAN_FLAG) != 0) &&
                        ((localMesgDefs[localMesgIndex].arch & Fit.ARCH_ENDIAN_MASK) != Fit.ARCH_ENDIAN_BIG)) {
                        FlipFieldDataByteOrder(typeSize, elements);
                    }

                    field = Factory.createField(mesg.num, fieldDef.num);

                    if (field != null) {
                        // For unknown fields the factory will create a field with the type set to 0, i.e. enum
                        // In this situation we should use the type found in the fieldDef instead
                        if (field.getName().equals("unknown")) {
                            field = new Field("unknown", fieldDef.num, fieldDef.type, 1, 0, "", false, Profile.Type.fromBaseType(fieldDef.type));
                        }

                        if(field.type != fieldDef.type) {
                            int profileSize = Fit.baseTypeSizes[(field.type & Fit.BASE_TYPE_NUM_MASK)];

                            if(typeSize < profileSize) {
                                field.type = fieldDef.type;
                            }
                            else if(typeSize != profileSize) {
                                // Demotion is hard. Don't read the field if the
                                // sizes are different. Use the profile type if the
                                // signedness of the field has changed.
                                read = false;
                            }
                        }

                        if(read) {
                            field.read(new ByteArrayInputStream(fieldData), fieldDef.size);
                        }

                        if (fieldDef.num == Fit.FIELD_NUM_TIMESTAMP) {
                            Long fieldTimestamp = field.getLongValue();

                            if (fieldTimestamp != null) {
                                timestamp = fieldTimestamp.longValue();
                                lastTimeOffset = (int) (timestamp & Fit.HDR_TIME_OFFSET_MASK);
                            }
                        }
                        // Allow messages containing the accumulated field to set the accumulated value
                        if (field.getIsAccumulated()) {
                            int i;
                            for (i = 0; i < field.getNumValues(); i++) {
                                long value = ((Number)field.getRawValue(i)).longValue();
                                for (Field containingField : mesg.fields) {
                                    for (FieldComponent component : containingField.components) {
                                        if ( ( component.fieldNum == field.num ) && ( component.accumulate ) ) {
                                            value = (long) ((((value / field.scale) - field.offset) + component.offset) * component.scale);
                                        }
                                    }
                                }
                                accumulator.set(mesg.num, field.getNum(), value);
                            }
                        }

                        if (field.getNumValues() > 0) {
                            mesg.addField(field);
                        }
                    }
                }

                fieldIndex++;

                if (fieldIndex >= localMesgDefs[localMesgIndex].fields.size()) {
                    // Now that the entire message is decoded we may evaluate subfields and expand components
                    for (int i = 0; i < mesg.fields.size(); i++) {
                        // Determine the active subfield and expand if it has any components
                        int activeSubfield = mesg.getActiveSubFieldIndex(mesg.fields.get(i).getNum());

                        if (activeSubfield == Fit.SUBFIELD_INDEX_MAIN_FIELD) {
                            if (mesg.fields.get(i).components.size() > 0) {
                                // Expand the main field components
                                expandComponents(mesg.fields.get(i), mesg.fields.get(i).components);
                            }
                        } else {
                            if (mesg.fields.get(i).subFields.get(activeSubfield).components.size() > 0) {
                                // Expand the subfield components
                                expandComponents(mesg.fields.get(i), mesg.fields.get(i).subFields.get(activeSubfield).components);
                            }
                        }
                    }

                    // Determine where to go next
                    if (localMesgDefs[localMesgIndex].getDeveloperFieldTotalSize() > 0) {
                        // There is developer data we need to read it
                        fieldIndex = 0;
                        fieldBytesLeft = 0;
                        state = STATE.DEV_FIELD_DATA;
                    } else {
                        // There is no data to parse return the message
                        state = STATE.RECORD;
                        return RETURN.MESG;
                    }
                }
            }
            break;
        }

        case DEV_FIELD_DATA: {
            MesgDefinition localMesgDef = localMesgDefs[localMesgIndex];
            DeveloperFieldDefinition fieldDef = localMesgDef.developerFields.get(fieldIndex);

            while (fieldBytesLeft == 0) {
                fieldDataIndex = 0;
                fieldBytesLeft = fieldDef.getSize();

                if (fieldBytesLeft == 0) {
                    if ((fieldIndex + 1) >= localMesgDefs[localMesgIndex].developerFields.size()) {
                        break;
                    }
                    fieldBytesLeft = localMesgDefs[localMesgIndex].developerFields.get(++fieldIndex).getSize();
                }
            }

            fieldData[fieldDataIndex++] = data;
            fieldBytesLeft--;

            if (fieldBytesLeft == 0) {
                DeveloperField field = new DeveloperField(fieldDef);
                int typeSize;
                int elements;

                // Ignore field if type is not supported.
                if (((fieldDef.getType() & Fit.BASE_TYPE_NUM_MASK) < Fit.BASE_TYPES)) {
                    typeSize = Fit.baseTypeSizes[(fieldDef.getType() & Fit.BASE_TYPE_NUM_MASK)];
                    elements = fieldDef.getSize() / typeSize;

                    if (((fieldDef.getType() & Fit.BASE_TYPE_ENDIAN_FLAG) != 0) &&
                        ((localMesgDef.arch & Fit.ARCH_ENDIAN_MASK) != Fit.ARCH_ENDIAN_BIG)) {
                        FlipFieldDataByteOrder(typeSize, elements);
                    }

                    field.read(new ByteArrayInputStream(fieldData), fieldDef.getSize());

                    if (field.getNumValues() > 0) {
                        mesg.addDeveloperField(field);
                    }
                }

                fieldIndex++;

                if (fieldIndex >= localMesgDef.developerFields.size()) {
                    // Mesg decode complete
                    state = STATE.RECORD;
                    return RETURN.MESG;
                }
            }
            break;
        }

        default:
            break;
        }

        return RETURN.CONTINUE;
    }

    private void FlipFieldDataByteOrder(int typeSize, int elements) {
        // Swap the bytes for each element.
        for (int element = 0; element < elements; element++) {
            for (int i = 0; i < (typeSize / 2); i++) {
                byte tmp = fieldData[element * typeSize + i];
                fieldData[element * typeSize + i] = fieldData[element * typeSize + typeSize - i - 1];
                fieldData[element * typeSize + typeSize - i - 1] = tmp;
            }
        }
    }

    protected void expandComponents(Field containingField, ArrayList<FieldComponent> componentList) {
        int offset = 0;
        int i;

        for (i = 0; i < componentList.size(); i++) {
            FieldComponent component = componentList.get(i);

            if (component.fieldNum != Fit.FIELD_NUM_INVALID) {
                Field componentField = Factory.createField(mesg.num, component.fieldNum);
                int subFieldIndex = mesg.getActiveSubFieldIndex(component.fieldNum);
                SubField subField = componentField.getSubField(subFieldIndex);
                Long bitsValue;
                Double value;

                // Mark that this field has been generated through expansion
                componentField.setIsExpanded(true);

                // Get raw bits value
                bitsValue = containingField.getBitsValue(offset, component.bits, componentField.isSignedInteger());

                if (bitsValue == null) {
                    break; // No more data for components.
                }

                if (component.accumulate) {
                    bitsValue = accumulator.accumulate(mesg.num, component.fieldNum, bitsValue, component.bits);
                }

                // If the component field itself has *one* component apply the scale and offset of the componentField's
                // (nested) component
                if (componentField.components.size() == 1) {
                    value = (((bitsValue / component.scale) - component.offset) + componentField.components.get(0).offset) * componentField.components.get(0).scale;
                    if (mesg.hasField(componentField.num)) {
                        mesg.getField(componentField.num).addRawValue(value);
                    }
                    else {
                        componentField.addRawValue(value);
                        mesg.addField(componentField);
                    }
                }
                // The component field is itself a composite field (more than one component).  Don't use scale/offset, containing
                // field data must already be encoded.  Add elements to it until we have added bitsvalue
                else if (componentField.components.size() > 1) {
                    int bitsAdded = 0;
                    long mask;

                    while (bitsAdded < component.bits) {
                        mask = ((long)1 << Fit.baseTypeSizes[componentField.type & Fit.BASE_TYPE_NUM_MASK]) - 1;
                        if (mesg.hasField(componentField.num)) {
                            mesg.getField(componentField.num).addValue(bitsValue & mask);
                        } else {
                            componentField.addValue(bitsValue & mask);
                            mesg.addField(componentField);
                        }
                        bitsValue >>>= Fit.baseTypeSizes[componentField.type & Fit.BASE_TYPE_NUM_MASK];
                        bitsAdded += Fit.baseTypeSizes[componentField.type & Fit.BASE_TYPE_NUM_MASK];
                    }
                }
                // componentField is an ordinary field, apply scale and offset as usual
                else {
                    if(subField == null) {
                        value = (((bitsValue / component.scale) - component.offset) + componentField.offset) * componentField.scale;
                    } else {
                        value = (((bitsValue / component.scale) - component.offset) + subField.offset) * subField.scale;
                    }

                    if (mesg.hasField(componentField.num)) {
                        mesg.getField(componentField.num).addRawValue(value);
                    } else {
                        componentField.addRawValue(value);
                        mesg.addField(componentField);
                    }
                }
            }
            offset += component.bits;
        }
    }

    public Mesg getMesg() {
        return mesg;
    }

    public boolean bytesAvailable(final InputStream input) throws IOException {
        boolean bytesAvailable = false;
        if ((currentByteIndex > 0) && (currentByteIndex < bytesRead)) {
            bytesAvailable = true;
        } else if (input.available() > 0) {
            bytesAvailable = true;
        }
        return bytesAvailable;
    }
}
